using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp;

namespace Zkwip.EPIC
{
    internal class CodeFile
    {
        private readonly Profile _profile;
        private readonly OutputBlock[] _blocks;

        private CodeFile(Profile profile)
        {
            _profile = profile;
            _blocks = new OutputBlock[profile.BlockNames.Length];
        }

        internal static CodeFile FromImage(Profile profile, Image<Rgb24> img)
        {
            var cf = new CodeFile(profile);

            for (int i = 0; i < profile.BlockNames.Length; i++)
            {
                cf._blocks[i] = new OutputBlock(profile.OutputBlockLength, profile.BlockNames[i], profile.BigEndian);
            }

            foreach ((int x, int y) in profile.Pixels())
            {
                var bits = profile.GetClosestPaletteColor(img[x, y]);
                cf.SetBlockPixel(x, y, bits);
            }

            return cf;
        }

        internal static CodeFile FromContent(Profile profile, string content)
        {
            var cf = new CodeFile(profile);
            cf.ReadSourceContent(content);
            return cf;
        }

        internal void SetBlockPixel(int x, int y, bool[] bits)
        {
            int index = GetBlockIndex(x, y);

            for (int c = 0; c < bits.Length; c++)
                _blocks[_profile.Interleaved ? 0 : c].SetBit(index + (_profile.Interleaved ? c : 0), bits[c]);
        }

        internal bool[] GetBlockPixel(int x, int y)
        {
            int index = GetBlockIndex(x, y);

            bool[] colorBits = new bool[_profile.Channels];

            for (int c = 0; c < _profile.Channels; c++)
                colorBits[c] = _blocks[(_profile.Interleaved ? 0 : c)].GetBit(index + (_profile.Interleaved ? c : 0));

            return colorBits;
        }

        private int GetBlockIndex(int x, int y)
        {
            int pixel = x + _profile.Width * y;

            if (_profile.Interleaved) 
                return pixel * _profile.Channels;

            return pixel;
        }

        private void ReadSourceContent(string content)
        {
            var cursor = 0;
            foreach (string _ in _profile.BlockNames)
            {
                var block = OutputBlock.FromText(ref cursor, content, _profile.OutputBlockLength, _profile.BigEndian);
                _blocks[FindBlockId(block.Name)] = block;
            }
        }

        private int FindBlockId(string name)
        {
            if (_profile.Interleaved) 
                return 0;

            // Match by name
            for (int c = 0; c < _profile.Channels; c++)
            {
                if (name == _profile.BlockNames[c])
                    return c;
            }

            return 0;
        }

        private string GenerateFileStart()
        {
            return $"// Image constants generated by EPIC\n// Size = {{w:{_profile.Width}, h:{_profile.Height}}}\n";
        }

        internal string BuildImageCode(bool disableProgmem)
        {
            string res = GenerateFileStart();

            for (int c = 0; c < _profile.BlockNames.Length; c++)
                res += _blocks[c].GenerateLiteral(disableProgmem);

            return res;
        }
    }
}