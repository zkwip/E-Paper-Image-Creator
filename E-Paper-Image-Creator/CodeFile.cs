using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp;

namespace Zkwip.EPIC
{
    internal class CodeFile
    {
        private readonly Profile _profile;
        private readonly OutputBlock[] _blocks;

        internal CodeFile(Profile profile, Image<Rgb24> img)
        {
            _blocks = new OutputBlock[profile.BlockNames.Length];
            _profile = profile;

            for (int i = 0; i < _profile.BlockNames.Length; i++)
            {
                _blocks[i] = new OutputBlock(_profile.OutputBlockLength, _profile.BlockNames[i], _profile.BigEndian);
            }

            foreach ((int x, int y) in _profile.Pixels())
            {
                var bits = _profile.GetClosestPaletteColor(img[x, y]);
                SetBlockPixel(x, y, bits);
            }
        }

        internal CodeFile(Profile profile, string content)
        {
            _profile = profile;
            _blocks = new OutputBlock[profile.BlockNames.Length];
            ReadSourceContent(content);
        }

        private void SetBlockPixel(int x, int y, bool[] bits)
        {
            int index = GetBlockIndex(x, y);

            if (_profile.Interleaved) 
                SetBlockPixelInterleaved(index, bits);
            else
                SetBlockPixelSequential(bits, index);
        }

        internal bool[] GetBlockPixel(int x, int y)
        {
            int index = GetBlockIndex(x, y);

            if (_profile.Interleaved)
                return GetBlockPixelInterleaved(index);
            else
                return GetBlockPixelSequential(index);
        }

        private bool[] GetBlockPixelInterleaved(int index)
        {
            bool[] colorBits = new bool[_profile.Channels];

            for (int c = 0; c < _profile.Channels; c++)
                colorBits[c] = _blocks[0].GetBit(index + c);

            return colorBits;
        }

        internal bool[] GetBlockPixelSequential(int index)
        {
            bool[] colorBits = new bool[_profile.Channels];

            for (int c = 0; c < _profile.Channels; c++)
                colorBits[c] = _blocks[c].GetBit(index);

            return colorBits;
        }

        private int GetBlockIndex(int x, int y)
        {
            int pixel = x + _profile.Width * y;
            if (_profile.Interleaved) 
                return pixel * _profile.Channels;

            return pixel;
        }

        private void SetBlockPixelInterleaved(int index, bool[] bits)
        {
            for (int i = 0; i < bits.Length; i++)
                _blocks[0].SetBit(index + i, bits[i]);
        }

        private void SetBlockPixelSequential(bool[] bits, int index)
        {
            for (int i = 0; i < _blocks.Length; i++)
                _blocks[i].SetBit(index, bits[i]);
        }

        private void ReadSourceContent(string content)
        {
            var cursor = 0;
            foreach (string _ in _profile.BlockNames)
            {
                var block = new OutputBlock(ref cursor, content, _profile.OutputBlockLength, _profile.BigEndian);

                _blocks[FindBlockId(block.Name)] = block;
            }
        }

        private int FindBlockId(string name)
        {
            if (_profile.Interleaved) 
                return 0;

            // Match by name
            for (int c = 0; c < _profile.Channels; c++)
            {
                if (name == _profile.BlockNames[c])
                    return c;
            }

            return 0;
        }

        private string GenerateFileStart()
        {
            return $"// Image constants generated by EPIC\n// Size = {{w:{_profile.Width}, h:{_profile.Height}}}\n";
        }

        internal string BuildImageCode(bool disableProgmem)
        {
            string res = GenerateFileStart();

            for (int c = 0; c < _profile.BlockNames.Length; c++)
                res += _blocks[c].GenerateLiteral(disableProgmem);

            return res;
        }
    }
}