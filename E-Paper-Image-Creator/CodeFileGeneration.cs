using System;
using System.Collections.Generic;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace Zkwip.EPIC
{
    internal class CodeFileGeneration
    {
        private static string GenerateChannelCode(List<byte> list, Channel c, int perLine = 16)
        {
            string res = $"\nconst unsigned char {c.CName}[] = {{";

            for (int i = 0; i < list.Count; i++)
            {
                res += String.Format("0x{0:x2}, ", list[i]);

                if (i % perLine == perLine - 1) res += "\n";
            }

            return res + "};\n";
        }

        private static string GenerateFileStart(Profile profile)
        {
            return $"// Image constants generated by EPIC\n// Size = {{w:{profile.Width}, h:{profile.Height}}}\n";
        }

        internal static string BuildImageCode(Image<Rgb24> img, Profile profile)
        {
            var channelCount = profile.Channels.Length;
            var workingBytes = new byte[channelCount];

            var outputBytes = new List<byte>[channelCount];

            for (int c = 0; c < channelCount; c++)
                outputBytes[c] = new List<byte>();

            var counter = 0;

            foreach (var pixel in ColorManagement.PixelColors(img, profile))
            {
                var bits = ColorManagement.Map(pixel, profile.Channels);

                for (int c = 0; c < channelCount; c++)
                {
                    byte bitmask = ImageTraversal.GetBitMask(profile, counter);

                    if (bits[c] != profile.Channels[c].StoreInverted)
                        workingBytes[c] += bitmask;
                }

                counter++;

                if (counter == 8)
                {
                    for (int c = 0; c < channelCount; c++)
                    {
                        outputBytes[c].Add(workingBytes[c]);
                        workingBytes[c] = 0;
                        counter = 0;
                    }
                }
            }

            if (counter != 0)
            {
                for (int c = 0; c < channelCount; c++)
                    outputBytes[c].Add(workingBytes[c]);
            }

            string res = CodeFileGeneration.GenerateFileStart(profile);

            for (int c = 0; c < channelCount; c++)
            {
                res += CodeFileGeneration.GenerateChannelCode(outputBytes[c], profile.Channels[c]);
            }

            return res;
        }
    }
}