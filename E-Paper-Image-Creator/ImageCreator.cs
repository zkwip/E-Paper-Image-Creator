using Cocona;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

namespace Zkwip.EPIC;

public class ImageCreator
{
    private static void Main(string[] args) => CoconaApp.Run(Epic, args);

    private static int Epic(string file, string? output)
    {
        try
        {
            if (!File.Exists(file))
                throw new Exception("The provided file does not exist");

            var img = new Bitmap(file);

            if (img.Size.IsEmpty)
                throw new Exception("The provided file is not an image file");

            string result = BuildImageCode(img, Profiles.RedBlack);

            Console.Write(result);
            
            if (output is not null)
                File.WriteAllText(output, result);

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
            return 1;
        }
    }

    private static int Difference(Color a, Color b) => Math.Abs(a.R - b.R) + Math.Abs(a.G - b.G) + Math.Abs(a.B - b.B);
    

    static string BuildImageCode(Bitmap img, Channel[] channels)
    {
        var channelCount = channels.Length;
        var workingBytes = new byte[channelCount];

        var outputBytes = new List<byte>[channelCount];

        for (int c = 0; c < channelCount; c++)
            outputBytes[c] = new List<byte>();
        
        var counter = 0;

        foreach(Color pixel in Pixels(img))
        {
            var bits = Map(pixel, channels);

            for (int c = 0; c < channelCount; c++)
            {
                byte bit = (byte)(bits[c]?(1<<counter):0);
                workingBytes[c] += bit;
            }

            counter++;

            if (counter == 8)
            {
                for (int c = 0; c < channelCount; c++)
                {
                    outputBytes[c].Add(workingBytes[c]);
                    workingBytes[c] = 0;
                    counter = 0;
                }
            }
        }

        if (counter != 0)
        {
            for (int c = 0; c < channelCount; c++)
                outputBytes[c].Add(workingBytes[c]);
        }

        string res = GenerateFileStart(img, channels);

        for (int c = 0; c < channelCount; c++)
        {
            res += GenerateChannelCode(outputBytes[c], channels[c]);
        }

        return res;
    }

    private static string GenerateFileStart(Bitmap img, Channel[] channels)
    {
        return $"// Image constants generated by EPIC\n// Size = {{w:{img.Width}, h:{img.Height}}}\n";
    }

    private static string GenerateChannelCode(List<byte> list, Channel c, int perLine = 16)
    {
        string res = $"\nconst unsigned char {c.CName}[] = {{";

        for (int i = 0; i < list.Count; i++)
        {
            res += String.Format("0x{0:x2}, ", list[i]);

            if (i % perLine == perLine - 1) res += "\n";
        }

        return res + "};\n";
    }

    private static bool[] Map(Color pixel, Channel[] channels)
    {
        bool[] map = new bool[channels.Length];

        for (int i = 0; i < channels.Length; i++)
        {
            Channel c = channels[i];
            if (Difference(pixel,c.Color) < c.Distance)
            {
                map[i] = true;
                return map;
            }
        }

        return map;
    }

    public static IEnumerable<Color> Pixels(Bitmap img)
    {
        for (int y = 0; y < img.Height; y++)
        {
            for (int x = 0; x < img.Width; x++)
            {
                yield return img.GetPixel(x, y);
            }
        }
    }
}

public struct Channel
{
    public string CName;
    public Color Color;
    public int Distance;
}

public static class Profiles
{ 
    public static readonly Channel[] RedBlack = new Channel[]
    {
        new Channel() { CName = "IMAGE_RED", Color = Color.Red, Distance = 100 },
        new Channel() { CName = "IMAGE_BLACK", Color = Color.Black, Distance = 300  },
    };
}