using Cocona;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

namespace Zkwip.EPIC;

public class ImageCreator
{
    private static void Main(string[] args) => CoconaApp.Run(Epic, args);

    private static int Epic(string file, string? output)
    {
        try
        {
            Profile profile = Profiles.BlackWhiteRed;

            if (!File.Exists(file))
                throw new Exception("The provided file does not exist");

            var img = new Bitmap(file);

            if (img.Size.IsEmpty)
                throw new Exception("The provided file is not an image file");

            if (img.Width < profile.Width || img.Height < profile.Height)
                throw new Exception("The image is smaller than the target");

            string result = BuildImageCode(img, Profiles.BlackWhiteRed);

            Console.Write(result);
            
            if (output is not null)
                File.WriteAllText(output, result);

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
            return 1;
        }
    }

    private static int Difference(Color a, Color b) => Math.Abs(a.R - b.R) + Math.Abs(a.G - b.G) + Math.Abs(a.B - b.B);
    

    static string BuildImageCode(Bitmap img, Profile profile)
    {
        var channelCount = profile.Channels.Length;
        var workingBytes = new byte[channelCount];

        var outputBytes = new List<byte>[channelCount];

        for (int c = 0; c < channelCount; c++)
            outputBytes[c] = new List<byte>();
        
        var counter = 0;

        foreach(Color pixel in PixelColors(img, profile))
        {
            var bits = Map(pixel, profile.Channels);

            for (int c = 0; c < channelCount; c++)
            {
                byte bitmask = GetBitMask(profile, counter);

                if (bits[c] != profile.Channels[c].StoreInverted)
                    workingBytes[c] += bitmask;
            }

            counter++;

            if (counter == 8)
            {
                for (int c = 0; c < channelCount; c++)
                {
                    outputBytes[c].Add(workingBytes[c]);
                    workingBytes[c] = 0;
                    counter = 0;
                }
            }
        }

        if (counter != 0)
        {
            for (int c = 0; c < channelCount; c++)
                outputBytes[c].Add(workingBytes[c]);
        }

        string res = GenerateFileStart(profile);

        for (int c = 0; c < channelCount; c++)
        {
            res += GenerateChannelCode(outputBytes[c], profile.Channels[c]);
        }

        return res;
    }

    private static byte GetBitMask(Profile profile, int counter)
    {
        var position = counter;

        if (profile.BigEndian)
            position = 7 - counter;

        byte bitmask = (byte)(1 << position);
        return bitmask;
    }

    private static string GenerateFileStart(Profile profile)
    {
        return $"// Image constants generated by EPIC\n// Size = {{w:{profile.Width}, h:{profile.Height}}}\n";
    }

    private static string GenerateChannelCode(List<byte> list, Channel c, int perLine = 16)
    {
        string res = $"\nconst unsigned char {c.CName}[] = {{";

        for (int i = 0; i < list.Count; i++)
        {
            res += String.Format("0x{0:x2}, ", list[i]);

            if (i % perLine == perLine - 1) res += "\n";
        }

        return res + "};\n";
    }

    private static bool[] Map(Color pixel, Channel[] channels)
    {
        bool[] map = new bool[channels.Length];

        for (int i = 0; i < channels.Length; i++)
        {
            Channel c = channels[i];
            if (Difference(pixel,c.Color) < c.Distance)
            {
                map[i] = true;
                return map;
            }
        }

        return map;
    }

    public static IEnumerable<Color> PixelColors(Bitmap img, Profile profile)
    {
        foreach (Point p in Pixels(profile.Size)) 
            yield return img.GetPixel(p.X, p.Y);
    }

    public static IEnumerable<Point> Pixels(Size size)
    {
        for (int y = 0; y < size.Height; y++)
        {
            for (int x = 0; x < size.Width; x++)
            {
                yield return new Point(x, y);
            }
        }
    }
}

public struct Channel
{
    public string CName;
    public Color Color;
    public int Distance;
    public bool StoreInverted;
}

public struct Profile
{
    // Alignment
    public int Width;
    public int Height;
    public bool BigEndian;

    public bool FlipHorizontal;
    public bool FlipVertical;

    // Colors
    public Channel[] Channels;
    public Color Background;

    // Properties
    public Size Size => new(Width, Height);
}

public static class Profiles
{
    public static readonly Profile BlackWhiteRed = new()
    {
        Width = 400,
        Height = 300,
        BigEndian = true,

        FlipHorizontal = false,
        FlipVertical = false,

        Channels = new Channel[]
        {
            new Channel()
            {
                CName = "IMAGE_RED",
                Color = Color.Red,
                Distance = 100,
                StoreInverted = true
            },
            new Channel()
            {
                CName = "IMAGE_BLACK",
                Color = Color.Black,
                Distance = 300,
                StoreInverted = true
            },
        },

        Background = Color.White
    };

}